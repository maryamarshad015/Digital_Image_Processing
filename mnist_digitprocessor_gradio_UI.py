# -*- coding: utf-8 -*-
"""MNIST_DigitProcessor_Final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1N2V8HF0NEQA-OJfxcETq7E0c3TGIpZ9I
"""

!pip install gradio scikit-image
from google.colab import output
output.enable_custom_widget_manager()  # Only needed in Colab

!pip install gradio scikit-image opencv-python matplotlib scikit-learn

import cv2
import numpy as np
import gradio as gr
from sklearn.datasets import fetch_openml
import matplotlib.pyplot as plt
import datetime
import os
import warnings
warnings.filterwarnings("ignore")

# Load MNIST dataset
print("Loading MNIST dataset...")
mnist = fetch_openml('mnist_784', version=1, as_frame=False)
images = (mnist.data.values if hasattr(mnist.data, 'values') else mnist.data).reshape(-1, 28, 28).astype(np.uint8)
labels = mnist.target.astype(int)
print(f"Dataset loaded! Shape: {images.shape}, Dtype: {images.dtype}")

class MNISTProcessor:
    def __init__(self):
        self.current_idx = 0
        self.current_image = images[self.current_idx]
        self.processed_image = self.current_image.copy()
        self.save_dir = "processed_images"
        if not os.path.exists(self.save_dir):
            os.makedirs(self.save_dir)

    def _convert_to_rgb(self, img):
        if len(img.shape) == 2:
            # Upscale the image for better visibility
            img = cv2.resize(img, (280, 280), interpolation=cv2.INTER_NEAREST)
            return np.stack((img,)*3, axis=-1)
        # If already RGB, just return it
        return img

    def _validate_image(self, img):
        if not isinstance(img, np.ndarray):
            img = np.array(img)
        if len(img.shape) == 3 and img.shape[2] == 3:
            img = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
        if img.dtype != np.uint8:
            img = img.astype(np.uint8)
        return img

    def get_current_image(self):
        return self._convert_to_rgb(self.current_image), f"Original (Label: {labels[self.current_idx]})"

    def update_image(self, change):
        self.current_idx = (self.current_idx + change) % len(images)
        self.current_image = images[self.current_idx]
        self.processed_image = self.current_image.copy()
        return self.get_current_image()

    def random_image(self):
        self.current_idx = np.random.randint(0, len(images))
        self.current_image = images[self.current_idx]
        self.processed_image = self.current_image.copy()
        return self.get_current_image()

    def apply_threshold(self, threshold):
        try:
            img = self._validate_image(self.current_image)
            threshold = int(threshold)
            _, self.processed_image = cv2.threshold(img, threshold, 255, cv2.THRESH_BINARY)
            return self._convert_to_rgb(self.processed_image), f"Threshold: {threshold}"
        except Exception as e:
            return None, f"Error: {str(e)}"

    def detect_edges(self, method):
        try:
            img = self._validate_image(self.current_image)
            if method == "Canny":
                self.processed_image = cv2.Canny(img, 100, 200)
            elif method == "Sobel":
                sobelx = cv2.Sobel(img, cv2.CV_64F, 1, 0, ksize=3)
                sobely = cv2.Sobel(img, cv2.CV_64F, 0, 1, ksize=3)
                self.processed_image = np.uint8(cv2.magnitude(sobelx, sobely))
            elif method == "Laplacian":
                self.processed_image = np.uint8(np.absolute(cv2.Laplacian(img, cv2.CV_64F, ksize=3)))
            elif method == "LoG":
                # Laplacian of Gaussian (LoG) edge detection
                blurred = cv2.GaussianBlur(img, (3, 3), 0)
                self.processed_image = np.uint8(np.absolute(cv2.Laplacian(blurred, cv2.CV_64F, ksize=3)))
            return self._convert_to_rgb(self.processed_image), f"{method} Edges"
        except Exception as e:
            return None, f"Error: {str(e)}"

    def apply_filter(self, method, kernel_size):
        try:
            img = self._validate_image(self.current_image)
            ksize = int(kernel_size)
            ksize = ksize if ksize % 2 == 1 else ksize + 1
            ksize = max(1, min(ksize, 31))

            if method == "Gaussian":
                self.processed_image = cv2.GaussianBlur(img, (ksize, ksize), 0)
            elif method == "Median":
                self.processed_image = cv2.medianBlur(img, ksize)
            elif method == "Mean":
                kernel = np.ones((ksize, ksize), np.float32) / (ksize * ksize)
                self.processed_image = cv2.filter2D(img, -1, kernel)
            return self._convert_to_rgb(self.processed_image), f"{method} Filter (Kernel: {ksize})"
        except Exception as e:
            return None, f"Error: {str(e)}"

    def find_contours(self):
        try:
            img = self._validate_image(self.current_image)
            _, binary = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)
            contours, _ = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

            # Create contour image with original size
            contour_img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
            cv2.drawContours(contour_img, contours, -1, (0, 255, 0), 1)

            # Upscale the contour image for better visibility
            self.processed_image = cv2.resize(contour_img, (280, 280), interpolation=cv2.INTER_NEAREST)
            return self._convert_to_rgb(self.processed_image), f"Found {len(contours)} contours"
        except Exception as e:
            return None, f"Error: {str(e)}"

    def show_histogram(self):
        try:
            img = self._validate_image(self.current_image)
            fig = plt.figure(figsize=(8, 4))
            plt.hist(img.ravel(), 256, [0, 256], color='blue', alpha=0.7)
            plt.title('Image Histogram')
            plt.xlabel('Pixel Value')
            plt.ylabel('Frequency')
            plt.grid(True, linestyle='--', alpha=0.5)
            plt.tight_layout()
            return fig
        except Exception as e:
            print(f"Error generating histogram: {str(e)}")
            return None

    def save_image(self):
        try:
            img = self._validate_image(self.processed_image)
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"mnist_{labels[self.current_idx]}_{timestamp}.png"
            save_path = os.path.join(self.save_dir, filename)
            cv2.imwrite(save_path, img)
            return f"Saved as {filename}"
        except Exception as e:
            return f"Error saving: {str(e)}"

# Initialize processor
processor = MNISTProcessor()

# Gradio Interface
with gr.Blocks(title="MNIST Digit Processor", theme=gr.themes.Soft()) as demo:
    gr.Markdown("# üñ•Ô∏è MNIST Digit Processor\n### Classical Image Processing Techniques")

    with gr.Row():
        with gr.Column():
            original_image = gr.Image(label="Original Image", height=500, width=500, image_mode="RGB")
            original_label = gr.Label(label="Image Info")
            with gr.Row():
                prev_btn = gr.Button("‚¨ÖÔ∏è Previous")
                next_btn = gr.Button("‚û°Ô∏è Next")
                random_btn = gr.Button("üé≤ Random")

        with gr.Column():
            processed_image = gr.Image(label="Processed Image", height=500, width=500, image_mode="RGB")
            processed_label = gr.Label(label="Processing Info")
            save_btn = gr.Button("üíæ Save Image")
            save_output = gr.Textbox(label="Save Status")

    with gr.Tabs():
        with gr.Tab("Thresholding"):
            threshold_slider = gr.Slider(0, 255, value=127, label="Threshold Value")
            threshold_btn = gr.Button("Apply Threshold")

        with gr.Tab("Edge Detection"):
            edge_method = gr.Radio(
                ["Canny", "Sobel", "Laplacian", "LoG"],
                value="Canny",
                label="Edge Detection Method"
            )
            edge_btn = gr.Button("Detect Edges")

        with gr.Tab("Filtering"):
            with gr.Row():
                filter_method = gr.Radio(["Gaussian", "Median", "Mean"], value="Gaussian", label="Method")
                kernel_size = gr.Slider(1, 31, value=3, step=2, label="Kernel Size")
            filter_btn = gr.Button("Apply Filter")

        with gr.Tab("Features"):
            with gr.Row():
                contour_btn = gr.Button("Find Contours")
                hist_btn = gr.Button("Show Histogram")
            feature_output = gr.Plot()

    # Navigation Events
    prev_btn.click(fn=lambda: processor.update_image(-1), outputs=[original_image, original_label])
    next_btn.click(fn=lambda: processor.update_image(1), outputs=[original_image, original_label])
    random_btn.click(fn=processor.random_image, outputs=[original_image, original_label])

    # Processing Buttons
    threshold_btn.click(fn=processor.apply_threshold, inputs=threshold_slider, outputs=[processed_image, processed_label])
    edge_btn.click(fn=processor.detect_edges, inputs=edge_method, outputs=[processed_image, processed_label])
    filter_btn.click(fn=processor.apply_filter, inputs=[filter_method, kernel_size], outputs=[processed_image, processed_label])
    contour_btn.click(fn=processor.find_contours, outputs=[processed_image, processed_label])
    hist_btn.click(fn=processor.show_histogram, outputs=feature_output)
    save_btn.click(fn=processor.save_image, outputs=save_output)

demo.launch(debug=True, share=True)